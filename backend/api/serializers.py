from rest_framework import serializers, validators

from django.db.models import Q, F, Sum, Case, When, IntegerField
from django.db.models.functions import Coalesce

from api import models

# Field class which allows for a representation of a foreign field to be the id
class ForeignKeyField(serializers.PrimaryKeyRelatedField):
    # `value` is just an id.
    def to_representation(self, value):
        if self.pk_field is not None:
            return self.pk_field.to_representation(value)
        return value

class TransactableSerializer(serializers.ModelSerializer):

    employee = serializers.IntegerField(required=False,
            source='employee_transactable__id')

    class Meta:
        model = models.Transactable
        fields = ('id', 'name', 'code', 'account_level', 'children',
                'parent', 'employee')

# Tree hierarchy is generated by recursively defining the class. 
# The users will aggregate values recursively for summary purposes.
class AccountHierarchySerializer(serializers.ModelSerializer):

    def to_representation(self, value):
        # Provide a reference to the employee
        if value.account_level == 'transactable':
            value = value.into_account()
            return TransactableSerializer(value).to_representation(value)
        return super(AccountHierarchySerializer, self).to_representation(value)

    class Meta:
        model = models.AccountBase
        fields = ('id', 'name', 'code', 'children', 'account_level',)

AccountHierarchySerializer._declared_fields['children'] = \
        AccountHierarchySerializer(many=True, source='_cached_children')

# Tree hierarchy is generated by recursively defining the class. 
# The users will aggregate values recursively for summary purposes.
class AccountSerializer(serializers.ModelSerializer):

    def to_representation(self, value):
        if value.account_level == 'transactable':
            value = value.into_account()
            return TransactableSerializer(value).to_representation(value)
        return super(AccountSerializer, self).to_representation(value)

    class Meta:
        model = models.AccountBase
        fields = ('id', 'name', 'code', 'parent', 'children', 'account_level',)

class EmployeeSalarySerializer(serializers.ModelSerializer):
    date = serializers.DateField(format='iso-8601',
            source='pay_period.start_date')
    class Meta:
        model = models.EmployeeSalary
        fields = ('id', 'date', 'total_ppay', 'employee')

class EmployeeSerializer(serializers.ModelSerializer):
    first_name = serializers.CharField(max_length=100)
    last_name = serializers.CharField(max_length=100)
    pid = serializers.IntegerField()
    salaries = EmployeeSalarySerializer(many=True)

    class Meta:
        model = models.EmployeeTransactable
        fields = ('id', 'first_name', 'last_name', 'pid', 'position_number',
                'transactable', 'salaries')

class FundSerializer(serializers.ModelSerializer):
    class Meta:
        model = models.Fund
        fields = ('id', 'name', 'code', 'budget', 'verified')

class SalarySerializer(serializers.ModelSerializer):
    date = serializers.DateField(format='iso-8601',
            source='pay_period.start_date')
    pay_period = ForeignKeyField(write_only=True,
            queryset=models.PayPeriod.objects.all())

    # Copies given data b/c post request data is immutable.
    def to_internal_value(self, data):
        data = data.copy()
        print(data)
        dmy = data['date']
        data['pay_period'] = models.PayPeriod.objects.get(start_date=dmy).id
        return super(SalarySerializer, self).to_internal_value(data)

    class Meta:
        model = models.EmployeeSalary
        fields = ('id', 'total_ppay', 'employee', 'date', 'pay_period')

class TransactionSerializer(serializers.ModelSerializer):
    date = serializers.SlugRelatedField(source='pay_period',
            queryset=models.PayPeriod.objects,
            slug_field='start_date')

    class Meta:
        model = models.Transaction
        fields = ('id', 'fund', 'date', 'transactable', 'paid', 'budget')

# This will get a summary of transactions, where the unique identifier is a
# triple field => { fund, transactable, pay_period }
# By using the PayPeriod class as the model, we make it so that a payment is
# returned for each pay period that exists in a given range, regardless of
# whether any transactions actually exist (yet).
class PaymentSerializer(serializers.ModelSerializer):
    # Include only when there exists exactly ONE transaction, for editing.
    id = serializers.IntegerField(required=False)

    # Unique identifiers
    date = serializers.DateField(format='iso-8601', read_only=True)
    fund = ForeignKeyField(queryset=models.Fund.objects)
    transactable = ForeignKeyField(queryset=models.Transactable.objects)

    # This is used when processing a CREATE request, see Meta.validators
    pay_period = ForeignKeyField(write_only=True,
            queryset=models.PayPeriod.objects.all())

    # Aggregated fields
    paid = serializers.FloatField()
    budget = serializers.FloatField()
    num_transactions = serializers.IntegerField(read_only=True)

    def to_internal_value(self, data):
        data = data.copy()
        dmy = data['date']
        data['pay_period'] = models.PayPeriod.objects.get(start_date=dmy).id
        return super(PaymentSerializer, self).to_internal_value(data)

    def to_representation(self, data):
        if isinstance(data, models.Transaction):
            return TransactionSerializer(data).to_representation(data)
        if data['num_transactions'] == 1:
            data['id'] = models.Transaction.objects.get(
                    pay_period__start_date=data['date'], fund=data['fund'],
                    transactable=data['transactable']).id
        return super(PaymentSerializer, self).to_representation(data)

    class Meta:
        model = models.Transaction
        fields = ('id', 'date', 'pay_period', 'fund', 'transactable',
                  'paid', 'budget', 'num_transactions')
        validators = [
            validators.UniqueTogetherValidator(
                    queryset=models.Transaction.objects.all(),
                    fields=('fund', 'transactable', 'pay_period')
            ),
        ]

# Read-Only serializer for getting summaries based on different fields.
class PaymentSummarySerializer(serializers.ModelSerializer):
    # Unique identifiers
    date = serializers.DateField(required=False)
    fund = serializers.IntegerField(required=False)
    transactable = serializers.IntegerField(required=False)

    # Aggregated fields
    paid = serializers.FloatField()
    budget = serializers.FloatField()

    class Meta:
        model = models.Transaction
        fields = ('date', 'fund', 'transactable', 'paid', 'budget')
        read_only_fields = ('date', 'fund', 'transactable', 'paid', 'budget')


