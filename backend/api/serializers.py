from rest_framework import serializers, validators

from django.db.models import Q, F, Sum, Case, When, IntegerField
from django.db.models.functions import Coalesce

import time

from api import models, fields

class PayPeriodField(serializers.DateField):
    def to_representation(self, value):
        return value.isoformat()
    def to_internal_value(self, representation):
        return fields.pay_period_from_iso(representation)

# Used to convert 'updated_on' to integer to allow frontend to determine most
# recent transactions.
class TimestampField(serializers.Field):
    def to_representation(self, value):
        return int(time.mktime(value.timetuple()))

# TODO: Optimize the account query.
class TransactableSerializer(serializers.ModelSerializer):

    class Meta:
        model = models.Transactable
        fields = ('id', 'name', 'code', 'account_level', 'children',
                'parent', 'has_indirect', 'is_indirect',
                'has_fringe', 'is_fringe')
        read_only_fields = ('account_level',)

class AccountSerializer(serializers.ModelSerializer):
    has_fringe = serializers.BooleanField()
    is_fringe = serializers.BooleanField()

    class Meta:
        model = models.Account
        fields = ('id', 'name', 'code', 'account_level',
                'children', 'fringe_sources', 'fringe_destination',
                'parent', 'has_fringe', 'is_fringe')
        read_only_fields = ('code', 'account_level',)

# Tree hierarchy is generated by recursively defining the class. 
# The users will aggregate values recursively for summary purposes.
class AccountBaseSerializer(serializers.ModelSerializer):

    def to_representation(self, value):
        if value.account_level == 'account':
            value = value.into_account()
            return AccountSerializer(value).to_representation(value)
        if value.account_level == 'transactable':
            value = value.into_account()
            return TransactableSerializer(value).to_representation(value)
        return super(AccountBaseSerializer, self).to_representation(value)

    class Meta:
        model = models.AccountBase
        fields = ('id', 'name', 'code', 'parent', 'children', 'account_level',)
        read_only_fields = ('code', 'account_level',)

class EmployeeSerializer(serializers.ModelSerializer):
    first_name = serializers.CharField(max_length=100)
    last_name = serializers.CharField(max_length=100)
    pid = serializers.IntegerField()
    updated_on = TimestampField(read_only=True)

    class Meta:
        model = models.EmployeeTransactable
        fields = ('id', 'first_name', 'last_name', 'pid', 'position_number',
                'transactable', 'updated_on')
        read_only_fields = ('updated_on',)

class FundSerializer(serializers.ModelSerializer):
    class Meta:
        model = models.Fund
        fields = ('id', 'name', 'code', 'budget', 'verified', 'editable_date')
        read_only_fields = ('code',)

# When serializing a queryset of salaries, the salaries should be ordered
# by the `start_date` field. 
class SalarySerializer(serializers.ModelSerializer):
    date = PayPeriodField(source='pay_period')
    updated_on = TimestampField(read_only=True)

    class Meta:
        model = models.EmployeeSalary
        fields = ('id', 'total_ppay', 'employee', 'date', 'updated_on')

class SalaryFileSerializer(serializers.ModelSerializer):
    # TODO: todo.txt question, should we even have this etc

    date = PayPeriodField(source='pay_period')

    class Meta:
        model = models.SalaryFile
        fields = ('id', 'file', 'comment', 'date')

class TransactionSerializer(serializers.ModelSerializer):
    date = PayPeriodField(source='pay_period')
    updated_on = TimestampField(read_only=True)

    class Meta:
        model = models.Transaction
        fields = ('id', 'fund', 'date', 'transactable', 'paid', 'budget',
                  'updated_on', 'is_manual')
        # Fund and transactable will be modifiable with the data integrity tool
        read_only_fields = ('date', 'is_manual',)

class TransactionMetadataSerializer(serializers.ModelSerializer):
    data = serializers.JSONField(binary=False)
    associated_transactions = \
        serializers.PrimaryKeyRelatedField(many=True, read_only=True)

    class Meta:
        model = models.TransactionMetadata
        fields = (
            'id', 'row_idx', 'source_file', 'data', 'associated_transactions')

# TODO: Include id's for associated_transactions instead of transaction objects.
class TransactionFileSerializer(serializers.ModelSerializer):
    # transactions = TransactionSerializer(many=True, source='transaction_set')

    class Meta:
        model = models.TransactionFile
        fields = ('id', 'file', 'comment', 'timestamp',)

# Read-Only serializer for getting summaries based on different fields.
class PaymentSummarySerializer(serializers.ModelSerializer):
    # Unique identifiers
    date = PayPeriodField(required=False)
    fund = serializers.IntegerField(required=False)
    transactable = serializers.IntegerField(required=False)

    # Aggregated fields
    paid = serializers.FloatField()
    budget = serializers.FloatField()

    # Latest update time found for aggregated transactions.
    updated_on = TimestampField(required=False, read_only=True)

    class Meta:
        model = models.Transaction
        fields = ('date', 'fund', 'transactable', 'paid', 'budget',
                'updated_on')
        read_only_fields = ('date', 'fund', 'transactable', 'paid', 'budget',
                'updated_on')

class FringeRateSerializer(serializers.ModelSerializer):
    date = PayPeriodField(source='pay_period')
    updated_on = TimestampField(read_only=True)

    class Meta:
        model = models.FringeRate
        fields = ('id', 'date', 'rate', 'account', 'updated_on')

class IndirectRateSerializer(serializers.ModelSerializer):
    date = PayPeriodField(source='pay_period')
    updated_on = TimestampField(read_only=True)

    class Meta:
        model = models.IndirectRate
        fields = ('id', 'date', 'rate', 'fund', 'updated_on')

class ClientSettingsSerializer(serializers.ModelSerializer):

    class Meta:
        model = models.ClientSettings
        fields = ('data', 'name')
        read_only_fields = ('name',)

