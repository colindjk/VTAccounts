from rest_framework import serializers, validators

from django.db.models import Q, F, Sum, Case, When, IntegerField
from django.db.models.functions import Coalesce

import time

from api import models, fields

class PayPeriodField(serializers.DateField):
    def to_representation(self, value):
        return value.isoformat()
    def to_internal_value(self, representation):
        return fields.pay_period_from_iso(representation)

# Field class which allows for a representation of a foreign field to be the id
class ForeignKeyField(serializers.PrimaryKeyRelatedField):
    # `value` is just an id.
    def to_representation(self, value):
        if self.pk_field is not None:
            return self.pk_field.to_representation(value)
        return value

# Used to convert 'updated_on' to integer to allow frontend to determine most
# recent transactions.
class TimestampField(serializers.Field):
    def to_representation(self, value):
        return int(time.mktime(value.timetuple()))

class TransactableSerializer(serializers.ModelSerializer):

    employee = serializers.IntegerField(required=False,
            source='employee_transactable__id')

    class Meta:
        model = models.Transactable
        fields = ('id', 'name', 'code', 'account_level', 'children',
                'parent', 'employee')

# Separate serializer for keeping track of associated rates.
# class AccountSerializer(serializers.ModelSerializer):

    # # TODO: Make this optional.
    # fringe_sources = serializers.IntegerField(required=False, many=True,
            # source='fringe_sources')

    # class Meta:
        # model = models.AccountBase
        # fields = ('id', 'name', 'code', 'parent', 'children', 'account_level'
                # 'fringe_sources')

# Tree hierarchy is generated by recursively defining the class. 
# The users will aggregate values recursively for summary purposes.
class AccountBaseSerializer(serializers.ModelSerializer):

    def to_representation(self, value):
        # if value.account_level == 'account':
            # value = value.into_account()
            # return AccountSerializer(value).to_representation(value)
        if value.account_level == 'transactable':
            value = value.into_account()
            return TransactableSerializer(value).to_representation(value)
        return super(AccountBaseSerializer, self).to_representation(value)

    class Meta:
        model = models.AccountBase
        fields = ('id', 'name', 'code', 'parent', 'children', 'account_level',)

class EmployeeSerializer(serializers.ModelSerializer):
    first_name = serializers.CharField(max_length=100)
    last_name = serializers.CharField(max_length=100)
    pid = serializers.IntegerField()
    updated_on = TimestampField(read_only=True)

    class Meta:
        model = models.EmployeeTransactable
        fields = ('id', 'first_name', 'last_name', 'pid', 'position_number',
                'transactable', 'updated_on')
        read_only_fields = ('updated_on',)

class FundSerializer(serializers.ModelSerializer):
    class Meta:
        model = models.Fund
        fields = ('id', 'name', 'code', 'budget', 'verified')

# When serializing a queryset of salaries, the salaries should be ordered
# by the `start_date` field. 
class SalarySerializer(serializers.ModelSerializer):
    date = PayPeriodField(source='pay_period')
    updated_on = TimestampField(read_only=True)

    class Meta:
        model = models.EmployeeSalary
        fields = ('id', 'total_ppay', 'employee', 'date', 'updated_on')

class SalaryFileSerializer(serializers.ModelSerializer):
    # TODO: todo.txt question, should we even have this etc
    # associated_salaries = 

    date = PayPeriodField(source='pay_period')

    class Meta:
        model = models.SalaryFile
        fields = ('id', 'file', 'comment', 'date', 'pay_period')

class TransactionSerializer(serializers.ModelSerializer):
    date = PayPeriodField(source='pay_period')
    updated_on = TimestampField(read_only=True)

    class Meta:
        model = models.Transaction
        fields = ('id', 'fund', 'date', 'transactable', 'paid', 'budget',
                  'updated_on', 'is_manual')
        read_only_fields = ('updated_on', 'is_manual')

# TODO: Include id's for associated_transactions instead of transaction objects.
class TransactionFileSerializer(serializers.ModelSerializer):
    # transactions = TransactionSerializer(many=True, source='transaction_set')

    class Meta:
        model = models.TransactionFile
        fields = ('file', 'comment', 'timestamp',)

# Read-Only serializer for getting summaries based on different fields.
class PaymentSummarySerializer(serializers.ModelSerializer):
    # Unique identifiers
    date = PayPeriodField(required=False)
    fund = serializers.IntegerField(required=False)
    transactable = serializers.IntegerField(required=False)

    # Aggregated fields
    paid = serializers.FloatField()
    budget = serializers.FloatField()

    # Latest update time found for aggregated transactions.
    updated_on = TimestampField(required=False, read_only=True)

    class Meta:
        model = models.Transaction
        fields = ('date', 'fund', 'transactable', 'paid', 'budget',
                'updated_on')
        read_only_fields = ('date', 'fund', 'transactable', 'paid', 'budget',
                'updated_on')

class FringeRateSerializer(serializers.ModelSerializer):
    date = PayPeriodField(source='pay_period')
    updated_on = TimestampField(read_only=True)

    class Meta:
        model = models.FringeRate
        fields = ('id', 'date', 'rate', 'account', 'updated_on')

class IndirectRateSerializer(serializers.ModelSerializer):
    date = PayPeriodField(source='pay_period')
    updated_on = TimestampField(read_only=True)

    class Meta:
        model = models.IndirectRate
        fields = ('id', 'date', 'rate', 'fund', 'updated_on')

class UserSettingsSerializer(serializers.ModelSerializer):
    class Meta:
        model = models.UserSettings
        fields = ('user', 'data')

