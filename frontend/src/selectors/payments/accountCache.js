import createCachedSelector, {LruObjectCache, LruMapCache} from 're-reselect';
import { createSelector } from 'reselect'

import store from 'store'
import * as records from 'selectors/records'
import * as forms from 'selectors/forms'
import { deepCopy } from 'util/helpers'
import { getPayPeriodRange } from 'util/payPeriod'

const defaultAggregates = { paid: 0, budget: 0, count: 0, }

// An instance of this class will exist for each component. The component will
// then "select" the fund and range.
class PaymentsCache {
  constructor() {
    // A check will be made to see if a selector matches the one generated by 
    // re-reselect. If not, then the returned account tree must be updated.
    // selectors = { fund: { date: selectorFunction } }
    this.selectors = {}

    // cachedPayments = { fund: { date: { account: payment, ... }, ... }, ... }
    this.cachedPayments = {}
    this.accounts = {}


    this.paymentSelector = createCachedSelector(
      records.getAccounts,
      records.getFunds,
      records.getPayments,
      (state, fund) => fund,
      (state, fund, date) => date,

      (accounts, funds, payments, fund, date) => {
        var accountData = {}
        
        for (var id in accounts) {
          accountData[id] = {}
          accountData[id][date] = { /* paid, budget, etc. */ }
        }
        return accounts
      }
    )(
      ({ records }, fund, date) => {
        var timestamp = 0
        const { payments } = records
        if (payments[fund] && payments[fund][date]) {
          timestamp = payments[fund][date].timestamp
        }
        const cacheKey = fund + "__" + date + "__" + timestamp
        return cacheKey
      },
    )
  }

  }


}

